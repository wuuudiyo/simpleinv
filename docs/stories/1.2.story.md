# Story 1.2: SQLite-Datenbank integrieren

## Status

Ready for Review

## Story

**As a** Entwickler,
**I want** eine SQLite-Datenbank im Main Process einrichten,
**so that** Daten lokal persistiert werden können.

## Acceptance Criteria

1. better-sqlite3 ist installiert und funktioniert im Main Process
2. Datenbank-Datei wird in `%APPDATA%/simpleinv/data.db` erstellt
3. Datenbank-Schema für Artikel ist definiert und wird beim ersten Start erstellt:
   - id (INTEGER PRIMARY KEY)
   - title (TEXT NOT NULL)
   - category_id (INTEGER, FK)
   - status (TEXT: 'in_stock' | 'listed' | 'sold' | 'returned')
   - purchase_platform, purchase_price, purchase_date, shipping_cost_in
   - sale_platform, sale_price, sale_date, fees, shipping_cost_out
   - created_at, updated_at
4. Datenbank-Schema für Kategorien ist definiert:
   - id (INTEGER PRIMARY KEY)
   - name (TEXT NOT NULL UNIQUE)
5. Datenbank-Schema für Settings ist definiert:
   - key (TEXT PRIMARY KEY)
   - value (TEXT)
6. IPC-Handler für Datenbank-Operationen sind vorbereitet (Grundstruktur)

## Tasks / Subtasks

- [x] Task 1: better-sqlite3 installieren und konfigurieren (AC: 1)
  - [x] `better-sqlite3` (Version 11.x) installieren: `npm install better-sqlite3`
  - [x] `@types/better-sqlite3` installieren: `npm install -D @types/better-sqlite3`
  - [x] `electron-rebuild` installieren: `npm install -D electron-rebuild`
  - [x] Rebuild-Script in package.json hinzufügen:
    ```json
    "rebuild": "electron-rebuild -f -w better-sqlite3",
    "postinstall": "electron-rebuild -f -w better-sqlite3"
    ```
  - [x] `npm run rebuild` ausführen und verifizieren dass kein Fehler auftritt
  - [x] Verifizieren dass App mit better-sqlite3 startet ohne `MODULE_NOT_FOUND` Fehler

- [x] Task 2: DatabaseService implementieren (AC: 1, 2)
  - [x] `src/main/database/index.ts` erstellen mit DatabaseService Klasse
  - [x] `app.getPath('userData')` verwenden um Pfad zu `%APPDATA%/simpleinv/` zu ermitteln
  - [x] Datenbank-Datei unter `{userData}/data.db` erstellen
  - [x] WAL-Modus aktivieren: `this.db.pragma('journal_mode = WAL')`
  - [x] Foreign Keys aktivieren: `this.db.pragma('foreign_keys = ON')`
  - [x] `initialize()`, `getDb()` und `close()` Methoden implementieren
  - [x] DatabaseService als Singleton exportieren

- [x] Task 3: Datenbank-Schema definieren (AC: 3, 4, 5)
  - [x] `src/main/database/schema.ts` erstellen
  - [x] `initializeSchema(db)` Funktion implementieren die alle Tabellen erstellt
  - [x] Categories-Tabelle erstellen (siehe SQL-Schema unten)
  - [x] Articles-Tabelle erstellen mit Foreign Key auf categories (siehe SQL-Schema unten)
  - [x] Settings-Tabelle erstellen (siehe SQL-Schema unten)
  - [x] Indizes für `articles.status` und `articles.category_id` erstellen
  - [x] Verifizieren dass Schema beim App-Start ohne Fehler erstellt wird

- [x] Task 4: Shared Types definieren (AC: 3, 4, 5)
  - [x] `src/shared/types/article.ts` erstellen mit `Article`, `ArticleInput`, `ArticleStatus` Types
  - [x] `src/shared/types/category.ts` erstellen mit `Category`, `CategoryInput` Types
  - [x] `src/shared/types/settings.ts` erstellen mit `ThemeSettings`, `AppSettings`, `ThemeMode` Types
  - [x] `src/shared/types/index.ts` erstellen für Re-Exports

- [x] Task 5: Repository-Grundstruktur vorbereiten (AC: 6)
  - [x] `src/main/database/repositories/` Ordner erstellen
  - [x] `src/main/database/repositories/articleRepository.ts` als leere Klasse anlegen (Stub)
  - [x] `src/main/database/repositories/categoryRepository.ts` als leere Klasse anlegen (Stub)
  - [x] `src/main/database/repositories/settingsRepository.ts` als leere Klasse anlegen (Stub)

- [x] Task 6: DatabaseService in Main Process einbinden
  - [x] In `src/main/index.ts` den DatabaseService importieren
  - [x] `databaseService.initialize()` beim App-Start aufrufen (nach `app.whenReady()`)
  - [x] `databaseService.close()` beim App-Beenden aufrufen (im `app.on('quit')` Handler)
  - [x] Verifizieren dass `data.db` Datei in `%APPDATA%/simpleinv/` erstellt wird

- [x] Task 7: Berechnungs-Utilities anlegen
  - [x] `src/shared/utils/calculations.ts` erstellen
  - [x] `calculateProfit(article)` Funktion implementieren
  - [x] `calculateRoi(article)` Funktion implementieren
  - [x] `withCalculations(article)` Wrapper-Funktion implementieren

## Dev Notes

### Kontext aus Story 1.1

Story 1.1 hat das Electron-Projekt mit folgender Struktur aufgesetzt:
- Electron Forge + Vite als Build-System
- React 19.x im Renderer
- TypeScript mit strikten Einstellungen
- Basis-Ordnerstruktur unter `src/main/`, `src/renderer/`, `src/shared/`, `src/preload/`

### SQLite Datenbank-Schema [Source: architecture/9-datenbank-schema.md]

```sql
-- Kategorien
CREATE TABLE IF NOT EXISTS categories (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE
);

-- Artikel
CREATE TABLE IF NOT EXISTS articles (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    title TEXT NOT NULL,
    category_id INTEGER,
    status TEXT NOT NULL DEFAULT 'in_stock'
        CHECK (status IN ('in_stock', 'listed', 'sold', 'returned')),
    purchase_platform TEXT,
    purchase_price REAL NOT NULL,
    purchase_date TEXT,
    shipping_cost_in REAL NOT NULL DEFAULT 0,
    sale_platform TEXT,
    sale_price REAL,
    sale_date TEXT,
    fees REAL NOT NULL DEFAULT 0,
    shipping_cost_out REAL NOT NULL DEFAULT 0,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE SET NULL
);

-- Einstellungen
CREATE TABLE IF NOT EXISTS settings (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL
);

-- Indizes
CREATE INDEX IF NOT EXISTS idx_articles_status ON articles(status);
CREATE INDEX IF NOT EXISTS idx_articles_category ON articles(category_id);
```

### Status-Werte [Source: architecture/9-datenbank-schema.md]

| DB-Wert | Display | Farbe |
|---------|---------|-------|
| `in_stock` | In Stock | Blau |
| `listed` | Listed | Orange |
| `sold` | Sold | Grün |
| `returned` | Returned | Rot |

### TypeScript Datenmodelle [Source: architecture/4-datenmodelle.md]

#### Article Type
```typescript
// src/shared/types/article.ts

export type ArticleStatus = 'in_stock' | 'listed' | 'sold' | 'returned';

export interface Article {
  id: number;
  title: string;
  categoryId: number | null;
  status: ArticleStatus;
  purchasePlatform: string | null;
  purchasePrice: number;
  purchaseDate: string | null;
  shippingCostIn: number;
  salePlatform: string | null;
  salePrice: number | null;
  saleDate: string | null;
  fees: number;
  shippingCostOut: number;
  createdAt: string;
  updatedAt: string;
}

export interface ArticleInput {
  title: string;
  categoryId: number | null;
  status: ArticleStatus;
  purchasePlatform?: string;
  purchasePrice: number;
  purchaseDate?: string;
  shippingCostIn?: number;
  salePlatform?: string;
  salePrice?: number;
  saleDate?: string;
  fees?: number;
  shippingCostOut?: number;
}

export interface ArticleWithCalculations extends Article {
  profit: number | null;
  roi: number | null;
}
```

#### Category Type
```typescript
// src/shared/types/category.ts

export interface Category {
  id: number;
  name: string;
}

export interface CategoryInput {
  name: string;
}
```

#### Settings Type
```typescript
// src/shared/types/settings.ts

export type ThemeMode = 'light' | 'dark' | 'custom';

export interface ThemeSettings {
  mode: ThemeMode;
  customColor?: string;
}

export interface AppSettings {
  theme: ThemeSettings;
}

export const SETTING_KEYS = {
  THEME: 'theme',
} as const;
```

### DatabaseService Implementierung [Source: architecture/8-backend-architektur.md]

```typescript
// src/main/database/index.ts

import Database from 'better-sqlite3';
import { app } from 'electron';
import path from 'path';

class DatabaseService {
  private db: Database.Database | null = null;
  private dbPath: string;

  constructor() {
    const userDataPath = app.getPath('userData');
    this.dbPath = path.join(userDataPath, 'data.db');
  }

  initialize(): void {
    this.db = new Database(this.dbPath);
    this.db.pragma('journal_mode = WAL');
    this.db.pragma('foreign_keys = ON');
    initializeSchema(this.db);
  }

  getDb(): Database.Database {
    if (!this.db) throw new Error('Database not initialized');
    return this.db;
  }

  close(): void {
    this.db?.close();
    this.db = null;
  }
}

export const databaseService = new DatabaseService();
```

### Berechnungs-Utilities [Source: architecture/4-datenmodelle.md]

```typescript
// src/shared/utils/calculations.ts

import { Article, ArticleWithCalculations } from '../types/article';

export function calculateProfit(article: Article): number | null {
  if (article.salePrice === null) return null;
  return (
    article.salePrice -
    article.purchasePrice -
    article.fees -
    article.shippingCostIn -
    article.shippingCostOut
  );
}

export function calculateRoi(article: Article): number | null {
  const profit = calculateProfit(article);
  if (profit === null || article.purchasePrice === 0) return null;
  return Math.round((profit / article.purchasePrice) * 10000) / 100;
}

export function withCalculations(article: Article): ArticleWithCalculations {
  return {
    ...article,
    profit: calculateProfit(article),
    roi: calculateRoi(article),
  };
}
```

### Coding Standards - DB Naming [Source: architecture/11-coding-standards.md]

**WICHTIG:** snake_case in DB, camelCase in TypeScript!

| Element | Konvention | Beispiel |
|---------|------------|----------|
| DB Tabellen | snake_case | `articles` |
| DB Spalten | snake_case | `purchase_price` |
| TS Interfaces | PascalCase | `Article` |
| TS Properties | camelCase | `purchasePrice` |

Der Dev Agent muss Mapping-Funktionen verwenden um zwischen DB-Format (snake_case) und TS-Format (camelCase) zu konvertieren.

### Native Module Handling [Source: architecture/16-dependency-management.md]

`better-sqlite3` ist ein natives Node-Modul und muss für Electron rebuilt werden:

```json
// package.json
{
  "scripts": {
    "rebuild": "electron-rebuild -f -w better-sqlite3",
    "postinstall": "electron-rebuild -f -w better-sqlite3"
  }
}
```

**Troubleshooting:**
| Problem | Lösung |
|---------|--------|
| `MODULE_NOT_FOUND` | `npm run rebuild` |
| `NODE_MODULE_VERSION mismatch` | Electron und Node.js Versionen prüfen |
| Build-Fehler Windows | Visual Studio Build Tools installieren |

### Backend-Ordnerstruktur [Source: architecture/8-backend-architektur.md]

```
src/main/
├── index.ts                   # Entry Point
├── window.ts                  # BrowserWindow Config
├── database/
│   ├── index.ts               # Database Service
│   ├── schema.ts              # Schema-Definition
│   └── repositories/
│       ├── articleRepository.ts
│       ├── categoryRepository.ts
│       └── settingsRepository.ts
├── ipc/
│   ├── index.ts               # Handler Registration
│   └── handlers/
└── services/
```

### Hinweise für den Dev Agent

1. **Native Module:** Nach der Installation von better-sqlite3 MUSS `npm run rebuild` ausgeführt werden. Ohne Rebuild wird die App mit einem `MODULE_NOT_FOUND` Fehler abstürzen.

2. **Speicherort:** Die Datenbank wird in `%APPDATA%/simpleinv/data.db` gespeichert. Der Ordner wird automatisch von Electron erstellt wenn `app.getPath('userData')` verwendet wird.

3. **WAL-Modus:** Write-Ahead Logging verbessert die Performance und Crash-Resistenz. MUSS aktiviert werden.

4. **Foreign Keys:** SQLite hat Foreign Keys standardmäßig deaktiviert! Sie müssen explizit aktiviert werden mit `PRAGMA foreign_keys = ON`.

5. **IPC ist NICHT Teil dieser Story:** Diese Story fokussiert NUR auf die Datenbank-Integration. Die IPC-Kommunikation kommt in Story 1.3.

6. **Repository-Stubs:** Die Repositories werden nur als leere Klassen angelegt. Die vollständige CRUD-Implementierung erfolgt in Epic 2.

### Testing

**Testing-Standards für diese Story:** [Source: architecture/14-testing-strategie.md]
- MVP-Phase: Keine automatisierten Tests erforderlich
- Manuelle Verifizierung der Acceptance Criteria ist ausreichend

**Manuelle Test-Checkliste:**
- [ ] `npm run rebuild` läuft ohne Fehler durch
- [ ] `npm start` startet die App ohne `MODULE_NOT_FOUND` Fehler
- [ ] `data.db` Datei wird in `%APPDATA%/simpleinv/` erstellt
- [ ] Datenbank enthält die drei Tabellen (categories, articles, settings)
- [ ] Datenbank enthält die zwei Indizes (idx_articles_status, idx_articles_category)
- [ ] App startet auch nach Neustart und lädt die existierende Datenbank

**Verifizierung der Datenbank-Struktur:**
Mit einem SQLite-Browser (z.B. DB Browser for SQLite) die `data.db` Datei öffnen und prüfen:
1. Tabellen `categories`, `articles`, `settings` existieren
2. `articles` hat alle 15 Spalten gemäß Schema
3. `articles.category_id` hat Foreign Key auf `categories.id`

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-06 | 0.1 | Initial story draft | SM Bob |

## Dev Agent Record

### Agent Model Used

Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References

- Vite/Rollup konnte `better-sqlite3` nicht dynamisch laden
- Lösung: `better-sqlite3` als external in `vite.main.config.ts` markiert
- Fix in `vite.main.config.ts:6-10` (rollupOptions.external)

### Completion Notes List

- `@electron/rebuild` verwendet statt `electron-rebuild` (aktuelleres Package)
- Vite Config angepasst um native Module korrekt zu behandeln
- Alle Acceptance Criteria erfüllt und manuell verifiziert
- DB wird erfolgreich in `%APPDATA%\SimpleInv\data.db` erstellt

### File List

**Neue Dateien:**
- `src/main/database/index.ts` - DatabaseService (Singleton)
- `src/main/database/schema.ts` - SQL Schema Definition
- `src/main/database/repositories/articleRepository.ts` - Repository Stub
- `src/main/database/repositories/categoryRepository.ts` - Repository Stub
- `src/main/database/repositories/settingsRepository.ts` - Repository Stub
- `src/shared/types/article.ts` - Article, ArticleInput, ArticleStatus Types
- `src/shared/types/category.ts` - Category, CategoryInput Types
- `src/shared/types/settings.ts` - ThemeSettings, AppSettings Types
- `src/shared/types/index.ts` - Re-Exports
- `src/shared/utils/calculations.ts` - Berechnungs-Utilities
- `src/shared/utils/index.ts` - Re-Exports

**Modifizierte Dateien:**
- `package.json` - Dependencies und rebuild Scripts hinzugefügt
- `src/main/index.ts` - DatabaseService Integration
- `vite.main.config.ts` - better-sqlite3 als external

## DOD Checklist Results

### 1. Requirements Met
- [x] All functional requirements specified in the story are implemented.
- [x] All acceptance criteria defined in the story are met.

**Details:**
- AC1: better-sqlite3 installiert und funktioniert ✓
- AC2: DB in `%APPDATA%/SimpleInv/data.db` erstellt ✓
- AC3: Articles-Schema mit allen Feldern ✓
- AC4: Categories-Schema ✓
- AC5: Settings-Schema ✓
- AC6: Repository-Stubs vorbereitet ✓

### 2. Coding Standards & Project Structure
- [x] Code adheres to Operational Guidelines
- [x] Code aligns with Project Structure
- [x] Adherence to Tech Stack
- [x] Adherence to Data Models (snake_case DB ↔ camelCase TS)
- [x] Basic security best practices applied
- [x] No new linter errors or warnings
- [x] Code is well-commented where necessary

### 3. Testing
- [x] Unit tests: N/A (MVP-Phase - keine automatisierten Tests erforderlich lt. Story)
- [x] Integration tests: N/A (MVP-Phase)
- [x] All tests pass: N/A
- [x] Test coverage: N/A

**Note:** Gemäß `architecture/14-testing-strategie.md` - MVP-Phase erfordert nur manuelle Verifizierung.

### 4. Functionality & Verification
- [x] Functionality manually verified (App startet, DB wird erstellt)
- [x] Edge cases considered (DB existiert bereits → kein Fehler)

**Manual Tests durchgeführt:**
- [x] `npm run lint` - keine Fehler
- [x] `npm run typecheck` - keine Fehler
- [x] `npm start` - App startet ohne Fehler
- [x] `data.db` in `%APPDATA%\SimpleInv\` erstellt

### 5. Story Administration
- [x] All tasks marked complete
- [x] Decisions documented (Bugfix für Vite/Rollup)
- [x] Story wrap up section completed

### 6. Dependencies, Build & Configuration
- [x] Project builds successfully
- [x] Project linting passes
- [x] New dependencies approved: `better-sqlite3`, `@electron/rebuild` (in Story spezifiziert)
- [x] Dependencies recorded in `package.json`
- [x] No known security vulnerabilities
- [x] No new environment variables

### 7. Documentation
- [x] Inline documentation: Ausreichend für Stub-Klassen
- [N/A] User-facing documentation: Keine User-facing Änderungen
- [N/A] Technical documentation: Architektur-Docs bereits vorhanden

### Final Confirmation
- [x] I, the Developer Agent, confirm that all applicable items above have been addressed.

**Summary:**
- SQLite-Datenbank erfolgreich integriert
- Alle 7 Tasks abgeschlossen
- Bugfix für Vite/Rollup natives Modul-Handling dokumentiert
- Story ist bereit für Review

## QA Results

*To be filled by QA Agent*
