# Story 3.1: Dashboard-Metriken implementieren

## Status

Approved

## Story

**As a** Benutzer,
**I want** auf dem Dashboard sofort meinen Gesamtprofit, offenen Warenwert und Artikelanzahl sehen,
**so that** ich meinen Business-Status in Sekunden erfassen kann.

## Acceptance Criteria

1. Dashboard zeigt 3 Metriken-Karten oberhalb der Inventar-Tabelle
2. **Karte 1 - Gesamtprofit:** Summe aller Profits von verkauften Artikeln (Status: "Sold")
   - Profit pro Artikel = Verkaufspreis − Kaufpreis − Gebühren − Versandkosten (ein + aus)
   - Formatierung als Währung (z.B. "€ 234,50")
   - Positive Werte in Grün, negative in Rot
3. **Karte 2 - Offener Warenwert:** Summe aller Kaufpreise von nicht verkauften Artikeln (Status: "In Stock" + "Listed")
   - Formatierung als Währung
4. **Karte 3 - Nicht verkaufte Artikel:** Anzahl der Artikel mit Status "In Stock" oder "Listed"
   - Formatierung als Ganzzahl
5. Metriken aktualisieren sich automatisch bei Änderungen an Artikeln (hinzufügen, bearbeiten, löschen)
6. Bei leerer Datenbank zeigen alle Metriken "€ 0,00" bzw. "0"
7. Karten haben ein ansprechendes Design passend zum gewählten Theme

## Tasks / Subtasks

- [ ] Task 1: Metrics Service im Backend implementieren (AC: 2, 3, 4, 6)
  - [ ] `src/main/services/metricsService.ts` erstellen
  - [ ] `getDashboardMetrics(): DashboardMetrics` implementieren
  - [ ] SQL Query für Gesamtprofit (nur Status 'sold')
  - [ ] SQL Query für offenen Warenwert (Status 'in_stock' + 'listed')
  - [ ] SQL Query für Anzahl nicht verkaufter Artikel
  - [ ] Edge Case: Leere Datenbank → alle Werte 0

- [ ] Task 2: Metrics IPC Handler implementieren (AC: 5)
  - [ ] `src/main/ipc/handlers/metricsHandlers.ts` erstellen
  - [ ] Handler für `metrics:getDashboard` implementieren
  - [ ] Handler in `src/main/ipc/index.ts` registrieren
  - [ ] Error Handling

- [ ] Task 3: Metrics Store erstellen (AC: 5, 6)
  - [ ] `src/renderer/stores/metricsStore.ts` erstellen mit Zustand
  - [ ] State: `metrics: DashboardMetrics`, `isLoading: boolean`, `error: string | null`
  - [ ] Actions: `loadMetrics()`
  - [ ] Initial State: alle Werte 0

- [ ] Task 4: MetricCard UI-Komponente erstellen (AC: 1, 7)
  - [ ] `src/renderer/components/ui/MetricCard.tsx` erstellen
  - [ ] Props: `title: string`, `value: string`, `icon?: ReactNode`, `colorClass?: string`
  - [ ] Theme-aware Styling (Light/Dark/Custom Mode)
  - [ ] Responsive Design

- [ ] Task 5: MetricsRow Komponente erstellen (AC: 1, 2, 3, 4, 7)
  - [ ] `src/renderer/components/dashboard/MetricsRow.tsx` erstellen
  - [ ] 3 MetricCards nebeneinander (Grid oder Flex)
  - [ ] Karte 1: "Gesamtprofit" mit Euro-Icon und Grün/Rot-Färbung
  - [ ] Karte 2: "Offener Warenwert" mit Box/Package-Icon
  - [ ] Karte 3: "Nicht verkauft" mit Count-Icon

- [ ] Task 6: Formatierungs-Utilities erstellen (AC: 2, 3, 4)
  - [ ] `src/renderer/utils/formatters.ts` erstellen (falls nicht vorhanden)
  - [ ] `formatCurrency(value: number): string` → "€ 234,50" Format
  - [ ] `formatNumber(value: number): string` → Ganzzahl mit Tausender-Trenner

- [ ] Task 7: DashboardPage Integration (AC: 1, 5)
  - [ ] MetricsRow in DashboardPage oberhalb der Tabelle einbinden
  - [ ] `useEffect` für initiales Laden der Metriken
  - [ ] Metriken neu laden wenn articleStore sich ändert (nach CRUD-Operationen)

- [ ] Task 8: Auto-Refresh Logik (AC: 5)
  - [ ] Nach `createArticle()` → Metriken neu laden
  - [ ] Nach `updateArticle()` → Metriken neu laden
  - [ ] Nach `deleteArticle()` → Metriken neu laden
  - [ ] Option A: articleStore ruft metricsStore.loadMetrics() auf
  - [ ] Option B: useEffect mit articles als Dependency

- [ ] Task 9: Manuelle Verifizierung (Alle AC)
  - [ ] App starten: 3 Metriken-Karten sichtbar oberhalb der Tabelle
  - [ ] Leere DB: Alle Werte zeigen "€ 0,00" bzw. "0"
  - [ ] Artikel mit Status "In Stock" hinzufügen (Kaufpreis €50)
  - [ ] → "Offener Warenwert" zeigt "€ 50,00", "Nicht verkauft" zeigt "1"
  - [ ] Artikel auf "Sold" setzen (Verkaufspreis €100, Gebühren €5, Versand €10)
  - [ ] → "Gesamtprofit" zeigt "€ 35,00" (100-50-5-10)
  - [ ] → "Offener Warenwert" zeigt "€ 0,00", "Nicht verkauft" zeigt "0"
  - [ ] Negative Profit testen: Verkaufspreis < Kaufpreis → Profit in Rot
  - [ ] Theme wechseln: Karten passen sich an

## Dev Notes

### Kontext aus vorherigen Stories

**Epic 1 (Stories 1.1-1.5)** haben die Basis geschaffen:
- Electron + React + TypeScript Setup
- SQLite-Datenbank mit Articles-Tabelle
- IPC-Kommunikation eingerichtet
- TailwindCSS konfiguriert mit Dark Mode
- Theme-System implementiert
- Zustand für State Management

**Epic 2 (Stories 2.1-2.6)** haben CRUD implementiert:
- ArticleRepository mit allen CRUD-Operationen
- ArticleTable mit Sortierung
- Profit wird bereits pro Artikel berechnet und angezeigt

### DashboardMetrics Interface [Source: architecture/5-apiipc-spezifikation.md]

```typescript
// src/shared/ipc/types.ts

export interface DashboardMetrics {
  totalProfit: number;        // Summe Profit aller "sold" Artikel
  openInventoryValue: number; // Summe Kaufpreise "in_stock" + "listed"
  unsoldCount: number;        // Anzahl "in_stock" + "listed"
}
```

### IPC Channels [Source: architecture/5-apiipc-spezifikation.md]

```typescript
// src/shared/ipc/channels.ts

export const IPC_CHANNELS = {
  // ... existing channels
  METRICS: {
    GET_DASHBOARD: 'metrics:getDashboard',
  },
} as const;
```

### Metrics API Interface [Source: architecture/5-apiipc-spezifikation.md]

```typescript
// src/shared/ipc/types.ts

export interface MetricsApi {
  getDashboard(): Promise<DashboardMetrics>;
}
```

### Metrics Service Implementation

```typescript
// src/main/services/metricsService.ts

import type Database from 'better-sqlite3';
import type { DashboardMetrics } from '../../shared/ipc/types';

export class MetricsService {
  constructor(private db: Database.Database) {}

  getDashboardMetrics(): DashboardMetrics {
    // Gesamtprofit: Summe aller Profits von "sold" Artikeln
    // Profit = sale_price - purchase_price - fees - shipping_cost_in - shipping_cost_out
    const profitResult = this.db.prepare(`
      SELECT COALESCE(SUM(
        COALESCE(sale_price, 0) -
        COALESCE(purchase_price, 0) -
        COALESCE(fees, 0) -
        COALESCE(shipping_cost_in, 0) -
        COALESCE(shipping_cost_out, 0)
      ), 0) as totalProfit
      FROM articles
      WHERE status = 'sold'
    `).get() as { totalProfit: number };

    // Offener Warenwert: Summe Kaufpreise nicht verkaufter Artikel
    const inventoryResult = this.db.prepare(`
      SELECT COALESCE(SUM(purchase_price), 0) as openInventoryValue
      FROM articles
      WHERE status IN ('in_stock', 'listed')
    `).get() as { openInventoryValue: number };

    // Anzahl nicht verkaufter Artikel
    const countResult = this.db.prepare(`
      SELECT COUNT(*) as unsoldCount
      FROM articles
      WHERE status IN ('in_stock', 'listed')
    `).get() as { unsoldCount: number };

    return {
      totalProfit: profitResult.totalProfit,
      openInventoryValue: inventoryResult.openInventoryValue,
      unsoldCount: countResult.unsoldCount,
    };
  }
}
```

### Metrics IPC Handler

```typescript
// src/main/ipc/handlers/metricsHandlers.ts

import { ipcMain } from 'electron';
import { IPC_CHANNELS } from '../../../shared/ipc/channels';
import { metricsService } from '../../services';

export function registerMetricsHandlers(): void {
  ipcMain.handle(IPC_CHANNELS.METRICS.GET_DASHBOARD, () => {
    return metricsService.getDashboardMetrics();
  });
}
```

### Metrics Store

```typescript
// src/renderer/stores/metricsStore.ts

import { create } from 'zustand';
import type { DashboardMetrics } from '../../shared/ipc/types';

interface MetricsState {
  metrics: DashboardMetrics;
  isLoading: boolean;
  error: string | null;
  loadMetrics: () => Promise<void>;
}

export const useMetricsStore = create<MetricsState>((set) => ({
  metrics: {
    totalProfit: 0,
    openInventoryValue: 0,
    unsoldCount: 0,
  },
  isLoading: false,
  error: null,

  loadMetrics: async () => {
    set({ isLoading: true, error: null });
    try {
      const metrics = await window.api.metrics.getDashboard();
      set({ metrics, isLoading: false });
    } catch (error) {
      set({ error: String(error), isLoading: false });
    }
  },
}));
```

### MetricCard Komponente

```typescript
// src/renderer/components/ui/MetricCard.tsx

interface MetricCardProps {
  title: string;
  value: string;
  icon?: React.ReactNode;
  colorClass?: string; // z.B. 'text-green-600' oder 'text-red-600'
}

// Design: Notion-inspiriert, Card-basiert
// - Heller Hintergrund in Light Mode, dunkler in Dark Mode
// - Dezente Border
// - Title klein/grau, Value groß/prominent
```

### Formatierungs-Utilities

```typescript
// src/renderer/utils/formatters.ts

/**
 * Formatiert einen Betrag als Euro-Währung
 * @param value - Betrag in Euro (z.B. 234.5)
 * @returns Formatierter String (z.B. "€ 234,50")
 */
export function formatCurrency(value: number): string {
  return new Intl.NumberFormat('de-DE', {
    style: 'currency',
    currency: 'EUR',
  }).format(value);
}

/**
 * Formatiert eine Ganzzahl mit Tausender-Trennern
 * @param value - Zahl
 * @returns Formatierter String (z.B. "1.234")
 */
export function formatNumber(value: number): string {
  return new Intl.NumberFormat('de-DE').format(value);
}
```

### Dashboard Integration Pattern

```typescript
// src/renderer/components/dashboard/DashboardPage.tsx

import { useEffect } from 'react';
import { useArticleStore } from '../../stores/articleStore';
import { useMetricsStore } from '../../stores/metricsStore';
import { MetricsRow } from './MetricsRow';
import { ArticleTable } from '../articles/ArticleTable';

export function DashboardPage() {
  const { articles, loadArticles } = useArticleStore();
  const { metrics, loadMetrics } = useMetricsStore();

  // Initial load
  useEffect(() => {
    loadArticles();
    loadMetrics();
  }, []);

  // Refresh metrics when articles change
  useEffect(() => {
    loadMetrics();
  }, [articles]); // Re-fetch when articles array changes

  return (
    <div className="p-6">
      <MetricsRow metrics={metrics} />
      <ArticleTable articles={articles} />
    </div>
  );
}
```

### Komponenten-Hierarchie [Source: architecture/6-komponenten-architektur.md]

```
DashboardPage
├── Header (bereits vorhanden)
├── MetricsRow                    ← NEU
│   ├── MetricCard (Gesamtprofit)
│   ├── MetricCard (Offener Warenwert)
│   └── MetricCard (Nicht verkauft)
├── ActionBar (bereits vorhanden)
└── ArticleTable (bereits vorhanden)
```

### File Locations [Source: architecture/10-projektstruktur.md]

```
src/
├── main/
│   ├── services/
│   │   └── metricsService.ts        ← NEU
│   └── ipc/
│       └── handlers/
│           └── metricsHandlers.ts   ← NEU
│
├── renderer/
│   ├── components/
│   │   ├── ui/
│   │   │   └── MetricCard.tsx       ← NEU
│   │   └── dashboard/
│   │       └── MetricsRow.tsx       ← NEU
│   ├── stores/
│   │   └── metricsStore.ts          ← NEU
│   └── utils/
│       └── formatters.ts            ← NEU oder erweitern
│
└── shared/
    └── ipc/
        └── types.ts                  ← DashboardMetrics hinzufügen
```

### Preload Script Erweiterung

Falls noch nicht vorhanden, muss `src/preload/index.ts` die Metrics API exponieren:

```typescript
metrics: {
  getDashboard: () => ipcRenderer.invoke(IPC_CHANNELS.METRICS.GET_DASHBOARD),
},
```

### Coding Standards [Source: architecture/11-coding-standards.md]

| Element | Konvention | Beispiel |
|---------|------------|----------|
| React Components | PascalCase | `MetricCard.tsx` |
| Stores | camelCase mit 'Store' | `metricsStore.ts` |
| Services | camelCase mit 'Service' | `metricsService.ts` |
| IPC Channels | kebab:case | `metrics:getDashboard` |

**Kritische Regeln:**
- IPC Calls nur über `window.api` im Renderer
- State Updates nur über Store Actions
- Berechnungen im Backend (SQL) für Performance
- Formatierung im Frontend für Locale-Awareness

### Testing

**Testing-Standards für diese Story:** [Source: architecture/14-testing-strategie.md]
- MVP-Phase: Keine automatisierten Tests erforderlich
- Manuelle Verifizierung der Acceptance Criteria ist ausreichend

**Manuelle Test-Checkliste:**
- [ ] `npm start` startet die App ohne Fehler
- [ ] 3 Metriken-Karten sind oberhalb der Tabelle sichtbar
- [ ] Bei leerer Datenbank: "€ 0,00" / "€ 0,00" / "0"
- [ ] Neuen Artikel hinzufügen (In Stock, €50 Kaufpreis)
- [ ] → Offener Warenwert: "€ 50,00", Nicht verkauft: "1"
- [ ] Artikel auf "Sold" setzen (€100 Verkauf, €5 Gebühren, €10 Versand)
- [ ] → Gesamtprofit: "€ 35,00" (grün), Offener Warenwert: "€ 0,00"
- [ ] Artikel mit Verlust verkaufen (Kaufpreis > Verkaufspreis)
- [ ] → Gesamtprofit zeigt negativen Wert in Rot
- [ ] Theme wechseln (Light/Dark/Custom) - Karten passen sich an
- [ ] Mehrere Artikel hinzufügen und löschen - Metriken aktualisieren sich

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-06 | 0.1 | Initial story draft | PO Sarah |

## Dev Agent Record

### Agent Model Used

*To be filled by Dev Agent*

### Debug Log References

*To be filled by Dev Agent*

### Completion Notes List

*To be filled by Dev Agent*

### File List

*To be filled by Dev Agent*

## QA Results

*To be filled by QA Agent*
