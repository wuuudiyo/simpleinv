# Story 1.5: Theme-System implementieren

## Status

Ready for Review

## Story

**As a** Benutzer,
**I want** zwischen Light Mode, Dark Mode und einer eigenen Hintergrundfarbe w√§hlen,
**so that** ich die App an meine Vorlieben anpassen kann.

## Acceptance Criteria

1. Theme-Toggle ist in der App-Bar sichtbar (Light/Dark/Custom)
2. Light Mode zeigt helle Hintergr√ºnde mit dunkler Schrift
3. Dark Mode zeigt dunkle Hintergr√ºnde mit heller Schrift
4. Custom Mode zeigt einen Color Picker f√ºr die Hintergrundfarbe
5. Textfarben passen sich automatisch an f√ºr ausreichenden Kontrast
6. Gew√§hltes Theme wird in der Datenbank (Settings-Tabelle) persistiert
7. Beim App-Start wird das gespeicherte Theme geladen und angewendet
8. Theme-Wechsel erfolgt ohne App-Neustart (reaktiv)

## Tasks / Subtasks

- [x] Task 1: Theme Types definieren (AC: 1, 4)
  - [x] In `src/shared/types/settings.ts` sicherstellen dass folgende Types existieren:
    - `ThemeMode = 'light' | 'dark' | 'custom'`
    - `ThemeSettings { mode: ThemeMode; customColor?: string }`
  - [x] `SETTING_KEYS.THEME = 'theme'` Konstante definieren

- [x] Task 2: Settings Repository implementieren (AC: 6, 7)
  - [x] `src/main/database/repositories/settingsRepository.ts` implementieren:
    - `get(key: string): string | null`
    - `set(key: string, value: string): void`
  - [x] JSON-Serialisierung f√ºr komplexe Werte (ThemeSettings)
  - [x] Verifizieren dass Settings in DB persistiert werden

- [x] Task 3: Settings IPC Handler implementieren (AC: 6, 7)
  - [x] `src/main/ipc/handlers/settingsHandlers.ts` erstellen
  - [x] Handler f√ºr `settings:get` implementieren
  - [x] Handler f√ºr `settings:set` implementieren
  - [x] Handler in `src/main/ipc/index.ts` registrieren

- [x] Task 4: Theme Store erstellen (AC: 7, 8)
  - [x] `src/renderer/stores/themeStore.ts` erstellen mit Zustand
  - [x] State: `theme: ThemeSettings`, `isLoading: boolean`
  - [x] Actions: `loadTheme()`, `setTheme(theme)`, `setMode(mode)`, `setCustomColor(color)`
  - [x] `loadTheme()` l√§dt Theme beim App-Start via IPC
  - [x] `setTheme()` speichert Theme via IPC und aktualisiert State

- [x] Task 5: Theme-Anwendung implementieren (AC: 2, 3, 5)
  - [x] `src/renderer/hooks/useTheme.ts` erstellen
  - [x] Hook wendet Theme auf `<html>` Element an:
    - Light: `class=""` oder `class="light"`
    - Dark: `class="dark"`
    - Custom: `class="custom"` + CSS Variable `--custom-bg-color`
  - [x] Dark Mode Tailwind-Klassen verwenden (`dark:bg-gray-900`, etc.)
  - [x] Custom Mode: Dynamische Hintergrundfarbe via CSS Variable

- [x] Task 6: Kontrast-Berechnung implementieren (AC: 5)
  - [x] `src/renderer/utils/colorUtils.ts` erstellen
  - [x] `getContrastColor(bgColor: string): 'light' | 'dark'` implementieren
  - [x] Luminanz-Berechnung f√ºr automatische Textfarbe
  - [x] Bei Custom Mode: Textfarbe automatisch anpassen

- [x] Task 7: Theme-Toggle Komponente erstellen (AC: 1)
  - [x] `src/renderer/components/settings/ThemeToggle.tsx` erstellen
  - [x] Segmented Control oder Dropdown mit Light/Dark/Custom
  - [x] Icons f√ºr jeden Mode (Sonne, Mond, Palette)
  - [x] Bei Custom: Color Picker einblenden

- [x] Task 8: Color Picker integrieren (AC: 4)
  - [x] `react-colorful` installieren: `npm install react-colorful`
  - [x] Color Picker in ThemeToggle bei Custom Mode anzeigen
  - [x] Hex-Farbwert in ThemeSettings speichern
  - [x] Vorschau der Farbe in Echtzeit

- [x] Task 9: Header mit Theme-Toggle erweitern (AC: 1)
  - [x] `Header.tsx` erweitern mit ThemeToggle Komponente
  - [x] Positionierung rechts neben Settings-Icon
  - [x] Responsive Design f√ºr Toggle

- [x] Task 10: App-Start Theme-Loading (AC: 7)
  - [x] In `App.tsx` oder Root-Komponente `loadTheme()` beim Mount aufrufen
  - [x] Loading-State w√§hrend Theme geladen wird (optional)
  - [x] Fallback zu Light Mode wenn kein Theme gespeichert

- [x] Task 11: Dark Mode Styling (AC: 2, 3)
  - [x] Alle Komponenten mit Dark Mode Varianten erweitern:
    - `bg-white dark:bg-gray-800`
    - `text-gray-900 dark:text-gray-100`
    - `border-gray-200 dark:border-gray-700`
  - [x] Header, Cards, Buttons, etc. anpassen
  - [x] Sicherstellen dass alle UI-Elemente im Dark Mode lesbar sind

- [x] Task 12: Manuelle Verifizierung (Alle AC)
  - [x] `npm start` startet die App ohne Fehler
  - [x] Theme-Toggle ist in Header sichtbar
  - [x] Light Mode: Helle Hintergr√ºnde, dunkle Schrift
  - [x] Dark Mode: Dunkle Hintergr√ºnde, helle Schrift
  - [x] Custom Mode: Color Picker erscheint
  - [x] Custom Farbe wird als Hintergrund angewendet
  - [x] Textfarben passen sich automatisch an
  - [x] App neu starten: Theme wird wiederhergestellt
  - [x] Theme-Wechsel erfolgt sofort ohne Neustart

## Dev Notes

### Kontext aus vorherigen Stories

**Story 1.1-1.4** haben die Basis geschaffen:
- Electron + React + TypeScript Setup
- SQLite-Datenbank mit Settings-Tabelle
- IPC-Kommunikation eingerichtet
- TailwindCSS konfiguriert mit Dark Mode (`class`)
- Basis-Layout mit Header und Dashboard

### Theme Types [Source: architecture/4-datenmodelle.md]

```typescript
// src/shared/types/settings.ts

export type ThemeMode = 'light' | 'dark' | 'custom';

export interface ThemeSettings {
  mode: ThemeMode;
  customColor?: string; // Hex color, e.g. "#3B82F6"
}

export interface AppSettings {
  theme: ThemeSettings;
}

export const SETTING_KEYS = {
  THEME: 'theme',
} as const;

export const DEFAULT_THEME: ThemeSettings = {
  mode: 'light',
};
```

### Settings Repository [Source: architecture/8-backend-architektur.md]

```typescript
// src/main/database/repositories/settingsRepository.ts

import type Database from 'better-sqlite3';

export class SettingsRepository {
  constructor(private db: Database.Database) {}

  get(key: string): string | null {
    const stmt = this.db.prepare('SELECT value FROM settings WHERE key = ?');
    const row = stmt.get(key) as { value: string } | undefined;
    return row?.value ?? null;
  }

  set(key: string, value: string): void {
    const stmt = this.db.prepare(`
      INSERT INTO settings (key, value) VALUES (?, ?)
      ON CONFLICT(key) DO UPDATE SET value = excluded.value
    `);
    stmt.run(key, value);
  }

  getJson<T>(key: string): T | null {
    const value = this.get(key);
    if (!value) return null;
    try {
      return JSON.parse(value) as T;
    } catch {
      return null;
    }
  }

  setJson<T>(key: string, value: T): void {
    this.set(key, JSON.stringify(value));
  }
}
```

### Settings IPC Handlers [Source: architecture/5-apiipc-spezifikation.md]

```typescript
// src/main/ipc/handlers/settingsHandlers.ts

import { ipcMain } from 'electron';
import { IPC_CHANNELS } from '../../../shared/ipc/channels';
import { settingsRepository } from '../../database/repositories/settingsRepository';

export function registerSettingsHandlers(): void {
  ipcMain.handle(IPC_CHANNELS.SETTINGS.GET, (_, key: string) => {
    return settingsRepository.getJson(key);
  });

  ipcMain.handle(IPC_CHANNELS.SETTINGS.SET, (_, key: string, value: unknown) => {
    settingsRepository.setJson(key, value);
  });
}
```

### Theme Store mit Zustand [Source: architecture/7-frontend-architektur.md]

```typescript
// src/renderer/stores/themeStore.ts

import { create } from 'zustand';
import type { ThemeSettings, ThemeMode } from '../../shared/types/settings';
import { SETTING_KEYS, DEFAULT_THEME } from '../../shared/types/settings';

interface ThemeState {
  theme: ThemeSettings;
  isLoading: boolean;
  loadTheme: () => Promise<void>;
  setTheme: (theme: ThemeSettings) => Promise<void>;
  setMode: (mode: ThemeMode) => Promise<void>;
  setCustomColor: (color: string) => Promise<void>;
}

export const useThemeStore = create<ThemeState>((set, get) => ({
  theme: DEFAULT_THEME,
  isLoading: true,

  loadTheme: async () => {
    set({ isLoading: true });
    try {
      const savedTheme = await window.api.settings.get(SETTING_KEYS.THEME);
      set({ theme: savedTheme ?? DEFAULT_THEME, isLoading: false });
    } catch (error) {
      console.error('Failed to load theme:', error);
      set({ theme: DEFAULT_THEME, isLoading: false });
    }
  },

  setTheme: async (theme: ThemeSettings) => {
    set({ theme });
    await window.api.settings.set(SETTING_KEYS.THEME, theme);
  },

  setMode: async (mode: ThemeMode) => {
    const { theme, setTheme } = get();
    await setTheme({ ...theme, mode });
  },

  setCustomColor: async (color: string) => {
    const { theme, setTheme } = get();
    await setTheme({ ...theme, mode: 'custom', customColor: color });
  },
}));
```

### useTheme Hook [Source: architecture/7-frontend-architektur.md]

```typescript
// src/renderer/hooks/useTheme.ts

import { useEffect } from 'react';
import { useThemeStore } from '../stores/themeStore';
import { getContrastColor } from '../utils/colorUtils';

export function useTheme() {
  const { theme, isLoading, loadTheme } = useThemeStore();

  // Load theme on mount
  useEffect(() => {
    loadTheme();
  }, [loadTheme]);

  // Apply theme to DOM
  useEffect(() => {
    const root = document.documentElement;

    // Remove all theme classes
    root.classList.remove('light', 'dark', 'custom');

    switch (theme.mode) {
      case 'dark':
        root.classList.add('dark');
        break;
      case 'custom':
        root.classList.add('custom');
        if (theme.customColor) {
          root.style.setProperty('--custom-bg-color', theme.customColor);
          // Auto-adjust text color based on background
          const textMode = getContrastColor(theme.customColor);
          root.style.setProperty('--custom-text-color', textMode === 'dark' ? '#111827' : '#F9FAFB');
        }
        break;
      default: // light
        root.classList.add('light');
    }
  }, [theme]);

  return { theme, isLoading };
}
```

### Color Utilities [Source: Custom Implementation]

```typescript
// src/renderer/utils/colorUtils.ts

/**
 * Calculate relative luminance of a hex color
 * Based on WCAG 2.0 formula
 */
export function getLuminance(hexColor: string): number {
  const hex = hexColor.replace('#', '');
  const r = parseInt(hex.slice(0, 2), 16) / 255;
  const g = parseInt(hex.slice(2, 4), 16) / 255;
  const b = parseInt(hex.slice(4, 6), 16) / 255;

  const toLinear = (c: number) =>
    c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);

  return 0.2126 * toLinear(r) + 0.7152 * toLinear(g) + 0.0722 * toLinear(b);
}

/**
 * Determine if text should be light or dark based on background color
 */
export function getContrastColor(bgColor: string): 'light' | 'dark' {
  const luminance = getLuminance(bgColor);
  // Use 0.179 as threshold (WCAG recommendation)
  return luminance > 0.179 ? 'dark' : 'light';
}

/**
 * Check if a string is a valid hex color
 */
export function isValidHexColor(color: string): boolean {
  return /^#[0-9A-Fa-f]{6}$/.test(color);
}
```

### ThemeToggle Komponente [Source: architecture/6-komponenten-architektur.md]

```typescript
// src/renderer/components/settings/ThemeToggle.tsx

import { HexColorPicker } from 'react-colorful';
import { useThemeStore } from '../../stores/themeStore';
import type { ThemeMode } from '../../../shared/types/settings';

const modes: { value: ThemeMode; label: string; icon: string }[] = [
  { value: 'light', label: 'Light', icon: '‚òÄÔ∏è' },
  { value: 'dark', label: 'Dark', icon: 'üåô' },
  { value: 'custom', label: 'Custom', icon: 'üé®' },
];

export function ThemeToggle() {
  const { theme, setMode, setCustomColor } = useThemeStore();

  return (
    <div className="relative">
      {/* Mode Selector */}
      <div className="flex rounded-lg bg-gray-100 dark:bg-gray-700 p-1">
        {modes.map((mode) => (
          <button
            key={mode.value}
            onClick={() => setMode(mode.value)}
            className={`
              px-3 py-1.5 text-sm rounded-md transition-colors
              ${theme.mode === mode.value
                ? 'bg-white dark:bg-gray-600 shadow-sm'
                : 'hover:bg-gray-200 dark:hover:bg-gray-600'
              }
            `}
            title={mode.label}
          >
            {mode.icon}
          </button>
        ))}
      </div>

      {/* Color Picker for Custom Mode */}
      {theme.mode === 'custom' && (
        <div className="absolute right-0 top-full mt-2 p-3 bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700 z-50">
          <HexColorPicker
            color={theme.customColor ?? '#3B82F6'}
            onChange={setCustomColor}
          />
          <div className="mt-2 text-center text-sm text-gray-500">
            {theme.customColor ?? '#3B82F6'}
          </div>
        </div>
      )}
    </div>
  );
}
```

### Dark Mode CSS Patterns [Source: architecture/7-frontend-architektur.md]

```css
/* src/renderer/index.css - Erweitern */

@layer base {
  body {
    @apply bg-gray-50 text-gray-900;
    @apply dark:bg-gray-900 dark:text-gray-100;
  }

  /* Custom Mode Background */
  .custom body {
    background-color: var(--custom-bg-color, #3B82F6);
    color: var(--custom-text-color, #F9FAFB);
  }
}
```

**Komponenten Dark Mode Pattern:**
```typescript
// Beispiel f√ºr Card mit Dark Mode
<div className="bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700">
```

### Tailwind Dark Mode Config [Source: tailwind.config.js]

```javascript
// tailwind.config.js (bereits in Story 1.4 konfiguriert)
module.exports = {
  darkMode: 'class', // Aktiviert class-based Dark Mode
  // ...
};
```

### Coding Standards [Source: architecture/11-coding-standards.md]

| Element | Konvention | Beispiel |
|---------|------------|----------|
| Stores | camelCase mit 'Store' | `themeStore.ts` |
| Hooks | camelCase mit 'use' | `useTheme.ts` |
| Utils | camelCase | `colorUtils.ts` |

### Hinweise f√ºr den Dev Agent

1. **Zustand installieren:** Falls noch nicht installiert: `npm install zustand`

2. **react-colorful installieren:** `npm install react-colorful` - leichtgewichtige Color Picker Library

3. **Dark Mode Tailwind:** Dark Mode ist bereits auf `class` konfiguriert. Die Klasse `dark` auf `<html>` aktiviert alle `dark:` Varianten.

4. **Custom Mode:** Bei Custom Mode wird eine CSS Variable `--custom-bg-color` gesetzt. Diese muss in relevanten Komponenten verwendet werden.

5. **Kontrast:** Die automatische Textfarben-Anpassung ist wichtig f√ºr Accessibility. Bei hellen Hintergr√ºnden dunkler Text, bei dunklen Hintergr√ºnden heller Text.

6. **Persistence:** Theme wird als JSON in der Settings-Tabelle gespeichert. Key ist `theme`, Value ist `{"mode":"dark"}` oder `{"mode":"custom","customColor":"#FF5733"}`.

7. **Loading State:** Beim App-Start kann es kurz zu einem Flash kommen. Optional: Splash-Screen oder verz√∂gertes Rendering bis Theme geladen.

### Testing

**Testing-Standards f√ºr diese Story:** [Source: architecture/14-testing-strategie.md]
- MVP-Phase: Keine automatisierten Tests erforderlich
- Manuelle Verifizierung der Acceptance Criteria ist ausreichend

**Manuelle Test-Checkliste:**
- [ ] `npm start` startet die App ohne Fehler
- [ ] Theme-Toggle (‚òÄÔ∏è/üåô/üé®) ist im Header sichtbar
- [ ] Klick auf ‚òÄÔ∏è: Light Mode aktiviert (helle Hintergr√ºnde)
- [ ] Klick auf üåô: Dark Mode aktiviert (dunkle Hintergr√ºnde)
- [ ] Klick auf üé®: Custom Mode aktiviert, Color Picker erscheint
- [ ] Farbe im Color Picker ausw√§hlen: Hintergrund √§ndert sich
- [ ] Bei heller Custom-Farbe: Dunkler Text
- [ ] Bei dunkler Custom-Farbe: Heller Text
- [ ] App schlie√üen und neu starten: Gew√§hltes Theme ist noch aktiv
- [ ] Theme-Wechsel erfolgt sofort ohne Flackern
- [ ] In `%APPDATA%/simpleinv/data.db` ‚Üí Settings-Tabelle enth√§lt Theme-Eintrag

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-06 | 0.1 | Initial story draft | PO Sarah |

## Dev Agent Record

### Agent Model Used

Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References

Keine Debug-Eintr√§ge erforderlich - Implementierung verlief ohne Probleme.

### Completion Notes List

- zustand und react-colorful als Dependencies hinzugef√ºgt
- Settings Repository mit get/set/getJson/setJson Methoden implementiert
- IPC Handler f√ºr settings:get und settings:set registriert
- Theme Store mit Zustand erstellt (loadTheme, setTheme, setMode, setCustomColor)
- useTheme Hook wendet Theme auf document.documentElement an
- Color Utilities f√ºr Luminanz-Berechnung und automatische Textfarbe
- ThemeToggle mit Segmented Control (Light/Dark/Custom) und Color Picker
- Alle Komponenten mit dark: Varianten f√ºr Dark Mode erweitert
- Custom Mode nutzt CSS Variables (--custom-bg-color, --custom-text-color)

### File List

**Neue Dateien:**
- src/main/ipc/handlers/settingsHandlers.ts
- src/renderer/stores/themeStore.ts
- src/renderer/hooks/useTheme.ts
- src/renderer/utils/colorUtils.ts
- src/renderer/components/settings/ThemeToggle.tsx
- src/renderer/components/settings/index.ts

**Modifizierte Dateien:**
- src/shared/types/settings.ts (DEFAULT_THEME hinzugef√ºgt)
- src/main/database/repositories/settingsRepository.ts (get/set/getJson/setJson implementiert)
- src/main/ipc/index.ts (registerSettingsHandlers hinzugef√ºgt)
- src/renderer/stores/index.ts (themeStore Export)
- src/renderer/hooks/index.ts (useTheme Export)
- src/renderer/utils/index.ts (colorUtils Export)
- src/renderer/components/index.ts (settings Export)
- src/renderer/App.tsx (useTheme Hook)
- src/renderer/index.css (Dark Mode und Custom Mode Styles)
- src/renderer/components/layout/Header.tsx (ThemeToggle + Dark Mode)
- src/renderer/components/layout/AppLayout.tsx (Dark Mode)
- src/renderer/components/ui/Card.tsx (Dark Mode)
- src/renderer/components/ui/Button.tsx (Dark Mode)
- src/renderer/components/dashboard/MetricCard.tsx (Dark Mode)
- src/renderer/components/dashboard/DashboardPage.tsx (Dark Mode)
- package.json (zustand, react-colorful)

## QA Results

*To be filled by QA Agent*
